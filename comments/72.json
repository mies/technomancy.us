{"timestamp":"Tue Feb 06 08:37:03 -0800 2007","uri":"http:\/\/technomancy.us","post_id":73,"author":"Phil","id":72,"content":"<p>Ian: that&#8217;s a pretty cool hack. Seriously. It looks to be very idiomatic Python.<\/p>\n\n\n\t<p>However, when you say, &#8220;the technique is applicable to any scripting-style language&#8221; I think you&#8217;re failing to see the point of what&#8217;s written here. The Python doctests use code embedded in strings (data) to specify behaviour, and that&#8217;s fine. However, doing that in Lisp would feel clunky because Lisp doesn&#8217;t enforce a strict separation of code and data. Lisp encourages you to cross that line. You might even say it&#8217;s the whole point of using Lisp. If something is code, express it in code; don&#8217;t hide it in a string.<\/p>\n\n\n\t<p>(Also: calling a technique that uses string-eval more elegant than a solution involving macros is highly suspect.)<\/p>\n\n\n\t<p>Finally: documentation-driven testing just <em>sounds wrong<\/em>. The article above makes the case that the names you use have a significant impact on how you go about your work. When you&#8217;re writing code, you care about how it <em>behaves<\/em>. Like it or not, how it is documented is entirely orthogonal to whether it functions correctly or not.<\/p>\n\n\n\t<p>Still, I&#8217;d say it&#8217;s a nifty technique if you&#8217;re using Python and don&#8217;t have the benifit of code-is-data. It could even be a nice solution in Ruby, although RSpec has an intelligent use of blocks and has the advantage of treating code as code rather than as strings.<\/p>"}
