{"timestamp":"Sat Oct 13 00:00:01 -0700 2007","title":"hardware hacks","id":70,"content":"<p><a\r\n      href='http:\/\/dev.technomancy.us\/phil\/wiki\/NorbertRobot'>Norbert<\/a>\r\n      is my latest project: a robot that I plan on building up and\r\n      programming.<\/p>\r\n\r\n<img src='\/static\/i\/die_roboter.jpg' \r\n     alt='die roboter' title='die roboter' align='right' \/>\r\n\r\n\r\n<p>I've got the motor hooked up and running, \"mocking out\" the control\r\n  logic to a pair of switches. The plan is to get my laptop on board\r\n  and control the motors through the serial port. Apparently the\r\n  circuitry for such a task involves using a UART chip to convert the\r\n  serial signals into something usable, which is going to be a bit of\r\n  a challenge for me; I haven't worked with ICs before.<\/p>\r\n\r\n<p>Currently Norbert is capable of backward and forward motion as well\r\n  as turning, though the limitation of using switches on the chassis\r\n  makes control somewhat impractical.<\/p>\r\n\r\n<p>The plan is all laid out in terms of what revisions will include\r\n  what features:<\/p>\r\n\r\n<ol>\r\n  <li>Simple motion (done)<\/li>\r\n  <li>Turning capability through switches (done)<\/li>\r\n  <li>Platform on which to mount laptop (done)<\/li>\r\n  <li>Laptop controls forward motion<\/li>\r\n  <li>Laptop controls turning<\/li>\r\n  <li>Laptop controls forward\/reverse<\/li>\r\n  <li>Autonomy (laptop can be provided with a predetermined path to\r\n    follow rather than requiring input each step of the way)<\/li>\r\n  <li>Bump sensors so that it will stop rather than keep pushing into an\r\n    unyielding object <\/li>\r\n  <li>... and more brainstorming\r\n  on <a href='http:\/\/dev.technomancy.us\/phil\/wiki\/NorbertRobot'>the\r\n  wiki page<\/a>.<\/li>\r\n<\/ol>\r\n\r\n<p>(<i>Italics<\/i> indicate completed revisions.)<\/p>\r\n\r\n<img src='\/static\/i\/norbert.jpg' alt='norbert'\r\n     title=\"lil' norbert\" \/>\r\n\r\n<p>I drummed up a bit of code for the controller before I had really\r\n  decided on parallel vs serial. (I had an old laptop I was\r\n  considering using that had an easier-to-interface-with parallel\r\n  port, but it was lacking a battery.) Hopefully it shouldn't be too difficult\r\n  to modify it to use the <a href='http:\/\/ruby-serialport.rubyforge.org'>\r\n    ruby-serialport<\/a> library.<\/p>\r\n\r\n    <pre class='code'>\r\n<span class=\"keyword\">class<\/span> <span class=\"type\">Robot<\/span>\r\n  <span class=\"type\">COMMAND_BITS<\/span> = [<span class=\"constant\">:right_motor_forward<\/span>, <span class=\"constant\">:right_motor_backward<\/span>,\r\n    <span class=\"constant\">:left_motor_forward<\/span>, <span class=\"constant\">:left_motor_backward<\/span>]\r\n\r\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">go_forward<\/span>\r\n    write_byte aggregate_commands(<span class=\"constant\">:right_motor_forward<\/span>, <span class=\"constant\">:left_motor_forward<\/span>)\r\n  <span class=\"keyword\">end<\/span>\r\n\r\n  <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">[go_backward and other commands...]\r\n<\/span>  \r\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">aggregate_commands<\/span>(*commands)\r\n    commands.inject(0) <span class=\"keyword\">do<\/span> |aggregate, command|\r\n      aggregate | bit_place(<span class=\"type\">COMMAND_BITS<\/span>.index(command))\r\n    <span class=\"keyword\">end<\/span>\r\n  <span class=\"keyword\">end<\/span>\r\n\r\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">bit_place<\/span>(place)\r\n    (2 ** place)\r\n  <span class=\"keyword\">end<\/span>\r\n\r\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">write_byte<\/span>(byte)\r\n    <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">http:\/\/blade.nagaokaut.ac.jp\/cgi-bin\/scat.rb\/ruby\/ruby-talk\/24605\r\n<\/span>    p = open(<span class=\"string\">'\/dev\/port'<\/span>, <span class=\"string\">'w'<\/span>)  <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">open \/dev\/port in write mode\r\n<\/span>    p.sync = <span class=\"variable-name\">true<\/span>               <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">turn buffering off, write to the\r\n<\/span>                                <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">port as soon as it is requested\r\n<\/span>    p.seek(0x378, <span class=\"type\">IO<\/span>::<span class=\"type\">SEEK_SET<\/span>) <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">move writing cursor to the parallel\r\n<\/span>                                <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">port address\r\n<\/span>    p.putc(byte)                <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">write byte to it and activate\r\n<\/span>                                <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">whatever on your I\/O board is \r\n<\/span>                                <span class=\"comment-delimiter\"># <\/span><span class=\"comment\">attached to the D0 pin\r\n  <span class=\"keyword\">end<\/span>\r\n<span class=\"keyword\">end<\/span>\r\n<\/pre>\r\n\r\n"}
