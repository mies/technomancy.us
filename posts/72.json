{"timestamp":"Sat Oct 13 00:00:01 -0700 2007","DRAFT":null,"title":"darjeeling - a roundabout route","id":72,"content":"<p>Well by now if you follow Ruby much you've probably noticed the\n  whole <a\n  href=\"http:\/\/on-ruby.blogspot.com\/2007\/01\/will-rubinius-be-acceptable-lisp.html\">Will Rubinius\n  be an acceptable Lisp<\/a> ponderings or brainstormings or whatever you want to\n  call it. And if you know me at all, you'd be aware that the\n  union of such concepts is exactly the kind of thing that would\n  excite me.<\/p>\n\n<p>So I meddled around a bit\n  with <a\n  href=\"http:\/\/parsetree.rubyforge.org\">ParseTree<\/a>. Honestly, it's\n  ridiculous; the Ruby side of this kind of thing has been made more\n  or less trivial by Ryan's great work:<\/p>\n\n  <pre class='code'>\nrequire <span class=\"string\">'rubygems'<\/span>\nrequire <span class=\"string\">'parse_tree'<\/span>\n\n<span class=\"keyword\">class<\/span> <span class=\"type\">Infuser<\/span>\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">self.brew<\/span>(klass)\n    lisp(<span class=\"type\">ParseTree<\/span>.new.parse_tree(klass)).sub(<span class=\"string\">\/\\(\\(\/<\/span>, <span class=\"string\">'(class Object ('<\/span>)\n<\/span>  <span class=\"keyword\">end<\/span>\n\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">self.lisp<\/span>(leaf)\n    leaf.respond_to?(<span class=\"constant\">:map<\/span>) ? <span class=\"string\">\"(<\/span><span class=\"variable-name\">#{leaf.map{|l| lisp(l)}<\/span><span class=\"string\">.join(' ')})\"<\/span> : leaf\n  <span class=\"keyword\">end<\/span>\n<span class=\"keyword\">end<\/span>\n<\/pre>\n\n<p>Would you look at that. Like I said; pretty trivial. While we're on the subject of trivial, consider this:<\/p>\n\n  <pre class='code'>\n<span class=\"keyword\">class<\/span> <span class=\"type\">Foo<\/span>\n  <span class=\"keyword\">def<\/span> <span class=\"function-name\">bar<\/span>\n    1 + 1\n  <span class=\"keyword\">end<\/span>\n<span class=\"keyword\">end<\/span><\/pre>\n\n\n<p><code>Infuser.brew Foo<\/code> gives us this:<\/p>\n\n<pre class='code'>\n(<span class=\"keyword\">class<\/span> <span class=\"type\">Object<\/span>\n       (<span class=\"keyword\">class<\/span> <span class=\"type\">Foo<\/span> (const <span class=\"type\">Object<\/span>) \n\t      (<span class=\"keyword\">defn<\/span> bar \n\t\t(<span class=\"keyword\">scope<\/span>\n\t\t (<span class=\"keyword\">block<\/span> (args) \n\t\t   (<span class=\"keyword\">call<\/span> (lit 1) + (array (lit 1))))))))\n<\/pre>\n\n<p>At this point you may be tempted to think yourself, \"Hey, that\n  looks like lisp! Run it through the compiler and see what it does.\"\n  Unfortunately Ruby's object model is wildly divergent from Common\n  Lisp's. (Though you could say that's very fortunate depending on\n  your opinion of <acronym title=\"Common Lisp Object System\">CLOS<\/acronym>&mdash;I won't go there.) The point is, running\n  the above code would require getting a subset of Ruby's object model\n  running in Common Lisp. Running nontrivial code would basically require\n  getting it completely ported.<\/p>\n\n<p>Now that sounds hugely daunting task. It probably is. But I've got\n  this wild idea that you'd only have to actually implement a fairly\n  small subset of this in CL itself. The rest could be translated over\n  from Ruby. I'm thinking all the portions of the\n  implementation currently written in C would need to be redone in CL,\n  and if the port is accurate enough then the portions of Ruby-the-implementation which are written\n  in Ruby-the-language will be able to be translated through the infuser shown\n  above. Now I know that the official Ruby has gobs and gobs of stuff\n  implemented in C, but it seems to be a stated goal\n  of <a href=\"http:\/\/rubini.us\/rubinius\">Rubinius<\/a> to decrease the\n  C-to-Ruby ratio. That may be something that could be leveraged\n  here. (Note to self: need to check out MetaRuby as well.)<\/p>\n\n<p>There's another hiccup though&mdash;it seems there's no solid\n  <acronym title=\"Behaviour-Driven Development\">BDD<\/acronym>\n  framework for Common Lisp. A few weeks back I started\n  writing <a\n  href=\"http:\/\/dev.technomancy.us\/phil\/browser\/dotfiles\/.emacs.d\/behave\">behave.el<\/a>\n  for Emacs Lisp. The pieces are all coming together in my head, so it\n  seems the thing to do at this point would be to finish it, port it\n  to CL, and then start porting the Rubinius specs to it.<\/p>\n\n<p>If this sounds totally insane to you, you're probably right. If it\n  doesn't, (or if it's the kind of insanity that intrigues you, and\n  you can't bring yourself to take your eyes away from such a wreck of an idea)\n  hop on the mailing list; I've got\n  a <a href=\"http:\/\/rubyforge.org\/projects\/darjeeling\">project<\/a> set\n  up at RubyForge. It's called Darjeeling.<\/p>\n"}
