{"timestamp":"Sat Oct 13 00:00:01 -0700 2007","DRAFT":null,"title":"arbis and kaizen","id":44,"content":"    <p>OK, so I've been playing with dynamic languages a lot. In the past\n    year I've somehow been able to get away with programming in Ruby and\n    Lisp almost exclusively. It's a rather refreshing feeling, especially\n    after wasting so much time with C++ in university. The funny thing is, a\n    good deal of the software I actually <i>use<\/i> is written in C.<\/p>\n    \n    <p>My recent excursions elisp have made me realize that working in\n    a dynamic language allows for an environment that you can mold and\n    shape on the fly to suit your whims. Such a system allows you to\n    grow more productive the more you use it, not only because you\n    learn more and more about the environment, but because the\n    environment also reciprocates and '<a\n    href='http:\/\/dev.technomancy.us\/phil\/browser\/dotfiles\/.emacs'>learns<\/a>'\n    more about you.<\/p>\n\n    <p>This is technically possible with programs written in C (or any\n    other non-dynamic language) if you are fairly familiar with the\n    source, but the feedback cycle is so much longer due to\n    compilation that you simply wouldn't bother with small\n    improvements. You're also stuck with the problem of what to do\n    with your customizations. If they're the sort of thing everyone\n    would like, then great, you submit a patch. If they're a matter of\n    taste and personal opinion, you might be able to make it an <a\n    href='http:\/\/ometer.com\/free-software-ui.html'>optional\n    preference<\/a> if you're lucky and don't mind cluttering up the\n    software. But otherwise when the next version comes out, it won't\n    have your customizations.<\/p>\n    \n    <p>But this is really only even relevant if you've already\n    invested a lot in C. I can't count the number of times I've felt\n    brave and checked something out of the GNOME CVS or the like,\n    somehow under the impression that I'd do some serious hacking or\n    at least grok it on some level. But the outcome was always the\n    same--I would soon realize that getting reacquainted with C was\n    one of the last things I'd like to be doing with my time.<\/p>\n    \n    <p>I've been able to get away with doing a lot of my everyday\n    tasks in Emacs, and Emacs rewards me for doing so in a\n    way. However, it can't do everything. It does a great job at\n    simple web browsing with w3m-mode, but there's simply no way it\n    can render CSS properly, and ECMAScript is out of the\n    question. (From what I gather the problem with CSS is that the\n    Emacs rendering engine is showing its age.) This lead me to play\n    around a bit with the <a\n    href='http:\/\/www.stud.uni-karlsruhe.de\/~unk6\/closure\/'>Closure<\/a>\n    web browser, but it's not exactly what you'd call mature.<\/p>\n    \n    <p><a href='http:\/\/www.loudthinking.com\/arc\/000557.html'>Someone\n    recently said<\/a> that reuse is vastly overrated:<\/p>\n    \n    <blockquote>Finally, the new economics of dynamic languages like Ruby\n    simply makes reuse a lot less attractive. Since the cost of producing\n    new, original code is so much lower, the demands on reuse are that\n    much greater. And usually that means it'll take more time to reuse\n    something than it'll take to create it from scratch.<\/blockquote>\n    \n    <p>So why bounce around between Epiphany, Firefox, and Closure?\n    Ruby's got <a\n    href='http:\/\/ruby-gnome2.sourceforge.jp\/hiki.cgi?RubyZilla'> what\n    you need to make a browser<\/a>. It's just a matter of tying\n    together the Gecko components in GTK and then customizing to your\n    heart's content. I've <a\n    href='http:\/\/dev.technomancy.us\/phil\/browser\/arbis'>started<\/a>\n    with a little project called Arbis as an experiment; we'll see how\n    it goes. It's already faster than both Firefox and Epiphany. I\n    suppose the biggest question is how 'deep' the ruby gecko bindings\n    go--if it's fairly surface-level it may not be useful for anything\n    more than a toy.<\/p>\n    \n<!--    <p>So all that to say that I've started to see static programs in\n    a different light. I have <a href='http:\/\/gaim.sf.net'>Gaim<\/a>\n    open right now, and on some level it's bothering me. Sure it's\n    nifty because it has nice icons and integrates with the panel more\n    nicely than Emacs would, but it's just so static. It's compiled\n    and set in stone; there's not much I can do about it. If I want to\n    make it better I'd have to hope someone had written a plugin for\n    what I'm thinking of. Contrast this to rcirc in Emacs, where all\n    that's needed is just poke some elisp and eval on the fly.<\/p>-->\n"}
