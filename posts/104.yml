--- 
timestamp: 2008-02-18 10:36:59
title: getting started with bus scheme
id: 104
content: " <p>So a number of folks have asked me how they should get started with Bus Scheme.[<a href='#fn1'>1</a>]. I've mostly just said silly things like, \"Umm... good question. Maybe read/watch <a href='http://mitpress.mit.edu/sicp/'>SICP</a>?\", which is silly because it doesn't have much to do with the <i>Bus</i> part of Bus Scheme, not because <i>The Structure and Interpretation of Computer Programs</i> is silly.</p>\n\
  <p>There's a poster in <a href='http://www.powells.com/'>my favourite bookstore</a> that has Dante's <i>Comedy</i>, the <i>Iliad</i>, and a few other classics captioned with something like \"Might as well start them now; you're going to have to read them eventually anyway.\" I hold the same notion regarding SICP and perhaps <i>The Little Schemer</i>, but I could see how it'd be helpful to have an introduction to Scheme from a Rubyist's perspective since reading a book like that can be large-ish mental investment.</p>\n\
  <p>Scheme is a programming language directly descended from Lisp. It's most often compared to Common Lisp, which is in some senses its big brother. Scheme is usually considered less \"kitchen-sink\"-ish than Common Lisp in that it only defines an extremely clean small core language and allows developers to extend it seamlessly to do what they need. In the words of the creators of Scheme:</p>\n\
  <blockquote> Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.\t     </blockquote>\n\
  <p>(As a potential student of Scheme, you should be encouraged by this notion as it directly translates into fewer concepts to learn.)</p>\n\
  <p>Ruby draws a lot of its heritage from Scheme, though Matz does not share the idea that a language should be limited to a very small number of core axioms from which everything else can be defined. [<a href='#fn2'>2</a>] Destructive method names ending in \"!\" and predicates ending in \"?\" were inspired by Scheme. Matz himself has even lightheartedly referred to Ruby as \"MatzLisp\". So this is a language that at the core should not feel too foreign to a Rubyist, even if the syntax looks quite different.</p>\n\
  <p>Let's dive in. <tt>sudo gem install bus-scheme</tt> if you haven't got it installed. Go ahead and launch Bus Scheme with the <tt>bus</tt> executable. Like <tt>irb</tt>, it drops you into a REPL, or Read-Eval-Print Loop. Scheme programs are made up of <b>expressions</b>. When you enter expressions into the REPL, they get evaluated and their value is shown. There are only a few simple rules for how expressions get evaluated that we'll address below. Feel free to experiment with entering expressions and seeing what gets returned.</p>\n\
  <p>The simplest expressions are just <b>atoms</b>, which are simple \"indivisible\" values, like symbols, numeric values, and strings. Some atoms evaluate to themselves just like in Ruby, so entering <tt>12</tt> into the REPL returns (and echoes) 12. <tt>\"foo\"</tt> works the same way. Symbols are a little different. Ruby uses a colon before the symbol's name, but in Scheme you refer to a symbol just using its name. So <tt>baz</tt> refers to the symbol with the name \"baz\". But if you enter <tt>baz</tt> into the REPL, Bus Scheme complains:</p>\n\
  <pre class='code'>&gt; baz Error: Undefined symbol: baz</pre>\n\
  <p>This is because symbols aren't considered <b>literals</b>; that is, they don't evaluate to themselves like they do in Ruby. When Bus Scheme encounters a symbol in this context, it treats it as a variable and tries to return the value that's bound to it, which doesn't work when it's not bound. So let's see what happens with a symbol that already has a value bound to it:</p>\n\
  <pre class='code'>&gt; + #&lt;Proc:0xb7c4b2a8@./bin/../lib/primitives.rb:16&gt;</pre>\n\
  <p>This is the way Bus Scheme represents a built-in (primitive) <b>function</b>. In Scheme, functions are first-class values, so you can bind them to variables, like you can with the <tt>lambda</tt> keyword in Ruby. But in Scheme this the primary way you refer to functions when you want to call them or pass them to other functions.</p>\n\
  <p>Speaking of calling functions, it works something like this:</p>\n\
  <pre class='code'>&gt; (+ 3 4) 7</pre>\n\
  <p>This is a <b>list</b>, which is Scheme's compound expression. This list is made up of three elements, in this case all atoms: the symbol <tt>+</tt>, the number 3, and the number 4. In normal contexts, when Scheme sees a list it treats it as a function call. First the first item in the list is evaluated, which evaluates to a Ruby Proc object. Then each of the remaining list elements are evaluated. Since they're all literals here, they evaluate to themselves. Then the arguments get passed to the function. Behind the scenes, this translates rougly into <tt>Proc.new{|*args| args.sum}.call(3, 4)</tt>. Let's see something a bit more complicated:</p>\n\
  <pre class='code'>&gt; (+ (+ 1 2) (+ 3 4)) 10</pre>\n\
  <p>In this case, the first <tt>+</tt> gets evaluated, and Bus Scheme sees that it's a function. So it looks at its arguments: <tt>(+ 1 2)</tt> gets evaluated to 3, and <tt>(+ 3 4)</tt> gets evaluated to 7. Then those two arguments get passed to <tt>+</tt> and the result becomes the value of the whole expression. </p>\n\
  <p>That's the basics of how program execution happens, but you won't get far without having a few more functions under your belt. Here are a some to get you rolling:</p>\n\
  <dl> <dt>+, -, *, and /</dt> <dd>You've been introduced to + above, but I'm sure you recognize your other old friends from grade-school days. + and * support any number of arguments, but - and / take two. In regular Scheme these all only work for numerical types, but Bus Scheme borrows Ruby's methods and lets you pass strings and other objects to + and *.</dd>\n\
  <dt>&lt;, &gt;, and =</dt> <dd>These are comparison functions. They work like they do in any language, but in Scheme you invoke them as <tt>(&gt; 3 7)</tt> etc. Again, Bus Scheme uses Ruby's underlying methods, so you can pass strings and other objects in, unlike in regular Scheme.</dd>\n\
  <dt>list</dt> <dd>If you want a list of numbers, you may think you get this by entering <tt>(1 2 3)</tt>. The problem with this is that in normal contexts it gets treated like a function call, and it will complain that 1 is not a function. What you can do instead is <tt>(list 1 2 3)</tt>, which evaluates to (1 2 3).</dd>\n\
  <dt>map</dt> <dd>This works like Ruby's map, but it's a free-standing function instead of a method. So instead of <tt>[1, 2, 3].map {|x| x + 3}</tt> you would do <tt>(map (lambda (x) (+ x 3)) (list 1 2 3)</tt>, which would return <tt>(4 5 6)</tt>.</dd>\n\
  <dt>substring</dt> <dd>Bus Scheme's <tt>(substring \"foobar\" 3 5)</tt> translates into <tt>\"foobar\"[3 .. 5]</tt> in Ruby.</dd>\n\
  <dt>if</dt> <dd>The most basic conditional is <tt>if</tt>. Use it like this: <tt>(if x \"x is true\" \"x is false\")</tt>. <tt>if</tt> evaluates its first argument, which in this case is x. If it evaluates to a true value [<a href='#fn3'>3</a>] then its second argument gets evaluated and returned. If it's false then the remaining arguments (if any) are evaluated and the last one is returned.[<a href='#fn4'>4</a>]</dd> </dl>\n\
  <p>Well, that's enough for now. You may not know enough to be dangerous, but I hope you know enough to explore. Tune in next time when I uncover the true Secrets of Lisp&trade; by explaining <tt>cons</tt>, <tt>lambda</tt>, and special forms.</p>\n\
  <hr />\n\
  <p><a name='fn1'>1</a> - I didn't say it was a large number.</p>\n\
  <p><a name='fn2'>2</a> - I imagine this causes <a href='http://blog.fallingsnow.net'>Evan</a> and <a href='http://headius.blogspot.com/'>Charles</a> some varying amounts of distress.</p>\n\
  <p><a name='fn3'>3</a> - In Scheme every value is true except <tt>#f</tt>, which is equivalent to Ruby's <tt>false</tt>.</p>\n\
  <p><a name='fn4'>4</a> - Observant readers will note that this does not follow the evaluation rule for functions given above which states that every argument is evaluated before the function is called. This is because <tt>if</tt> is not technically a function, but rather a <b>special form</b>, and different rules apply for the evaluation of a special form's arguments. There's more to this than I can cover in this article, but these rules allow for great syntactic flexibility.</p> "
